<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE module SYSTEM "api.dtd">

<module name="pygame2.base">
  <show>0</show>
  <alias>pygame2</alias>
  <short>basic features used by pygame2</short>
  <desc>
    Base features for pygame2 that are shared shared and used throughout
    the whole pygame2 package.
  </desc>

  <data name="__version__">
    The version of the pygame2 package as string.
  </data>

  <data name="version_info">
    The version of the pygame2 package as value tuple. The tuple is of
    the form ``('major', 'minor', 'micro', 'releaselevel')``, where all
    values except the *releaselevel* are integers.
  </data>

  <class name="BufferProxy">
    <constructor>BufferProxy () -> BufferProxy</constructor>
    <desc>Creates a new, empty BufferProxy.

    A buffer interface object that acts as a proxy on classes and
    attributes not featuring the buffer interface. A
    BufferProxy usually should be constructed from C code, not Python.
    </desc>
    <attr name="length">
      <desc>Gets the size of the buffer data in bytes.</desc>
    </attr>
    <attr name="raw">
      <desc>Gets the raw buffer data as string. The string may contain
      NUL bytes.</desc>
    </attr>
    <method name="write">
      <call>write (buffer, offset) -> None</call>
      <desc>
        Writes raw data to the BufferProxy.

        Writes the raw data from *buffer* to the BufferProxy object,
        starting at the specified *offset* within the BufferProxy. If
        the length of the passed *buffer* exceeds the length of the
        BufferProxy (reduced by *offset*), an :exc:`IndexError` will
        be raised.
      </desc>
    </method>
  </class>

  <class name="Color">
    <constructor>Color (...) -> Color</constructor>
    <desc>Creates a new Color object.

    The Color class represents RGBA color values using a value range of
    0-255. It allows basic arithmetic operations to create new colors,
    supports conversions to other color spaces such as HSV or HSL and lets
    you adjust single color channels. The following constructors are supported:
    
    * Color (0xAARRGGBB)
    * Color (0xRRGGBB)
    * Color (r, g, b, a)
    * Color (r, g, b)
    * Color ("0xRRGGBBAA")
    * Color ("#RRGGBBAA")
    * Color ("name")
    </desc>
    <example>
      from pygame2 import Color

      red = Color (255, 0, 0)
      green = Color (0x0000FF00)
      blue = Color ("blue")
    </example>
    <attr name="a">
      <desc>Gets or sets the alpha value of the Color.</desc>
    </attr>
    <attr name="b">
      <desc>Gets or sets the blue value of the Color.</desc>
    </attr>
    <attr name="cmy">
      <desc>The CMY representation of the Color. The CMY
      components are in the ranges C = [0, 1], M = [0, 1], Y = [0,
      1]. Note that this will not return the absolutely exact CMY values
      for the set RGB values in all cases. Due to the RGB mapping from
      0-255 and the CMY mapping from 0-1 rounding errors may cause the
      CMY values to differ slightly from what you might expect.</desc>
    </attr>
    <method name="correct_gamma">
      <call>correct_gamma (gamma) -> Color</call>
      <desc>
        Applies a certain gamma value to the Color.

        Applies a certain *gamma* value to the Color and returns a new
        Color with the adjusted RGBA values. The *gamma* value will be
        used as exponent for a power of calculation to adjust the actual
        gamma tone.

        The passed *gamma* value will influence he overall luminance of
        the color, where the following rules apply.
        
        * Pure white and black colors (R = G = B = 255 or 0) won't be effected by adjusting the gamma value.
        * the smaller the gamma factor, the higher the luminance and thus the brighter the color channels will be.
      </desc>
      <example>
        from pygame2 import Color

        color = Color (127, 127, 127)
        # 1.0 has no effect - corrected will be (127, 127, 127)
        corrected = color.correct_gamma (1.0)
        # 0.5 brightens the color by two - brightened will be (180, 180, 180)
        brightened = color.correct_gamma (0.5)
        # 2.0 darkens the color by two - darkened will be (63, 63, 63)
        darkened = color.correct_gamma (2.0)
      </example>
    </method>
    <attr name="g">
      <desc>Gets or sets the green value of the Color.</desc>
    </attr>
    <attr name="hsla">
      <desc>The HSLA representation of the Color. The HSLA
      components are in the ranges H = [0, 360], S = [0, 100], L = [0, 100],
      A = [0, 100]. Note that this will not return the absolutely exact HSL
      values for the set RGB values in all cases. Due to the RGB mapping from
      0-255 and the HSL mapping from 0-100 and 0-360 rounding errors may cause
      the HSL values to differ slightly from what you might expect.</desc>
    </attr>
    <attr name="hsva">
      <desc>The HSVA representation of the Color. The HSVA
      components are in the ranges H = [0, 360], S = [0, 100], V = [0, 100],
      A = [0, 100]. Note that this will not return the absolutely exact HSV
      values for the set RGB values in all cases. Due to the RGB mapping from
      0-255 and the HSV mapping from 0-100 and 0-360 rounding errors may cause
      the HSV values todiffer slightly from what you might expect.</desc>
    </attr>
    <attr name="i1i2i3">
      <desc>The I1I2I3 representation of the Color.
      The I1I2I3 components are in the ranges I1 = [0, 1], I2 = [-0.5, 0.5],
      I3 = [-0.5, 0.5]. Note that this will not return the absolutely exact
      I1I2I3 values for the set RGB values in all cases. Due to the RGB mapping
      from 0-255 and the I1I2I3 from 0-1 rounding errors may cause the I1I2I3
      values to differ slightly from what you might expect.</desc>
    </attr>
    <method name="normalize">
      <call>normalize() -> (float, float, float, float)</call>
      <desc>
        Returns the normalized RGBA values of the Color.

        Returns the normalized RGBA values of the Color as floating
        point values.
      </desc>
      <example>
        from pygame2 import Color

        color = Color (255, 255, 255)
        # normalized will be (1.0, 1.0, 1.0, 1.0)
        normalized = color.normalize ()
      </example>
    </method>
    <attr name="r">
      <desc>Gets or sets the red value of the Color.</desc>
    </attr>
  </class>

  <class name="Error">
    <constructor>Error (...) -> Error</constructor>
    <desc>
      A specialized exception class that indicates a misbehavior within the
      pygame2 modules.
    </desc>
  </class>

  <class name="FRect">
    <constructor>FRect (...) -> FRect</constructor>
    <desc>
      A class for storing rectangular coordinates.

      A FRect is used to store and manipulate rectangular coordinates.
    </desc>
    <attr name="bottom">
      <desc>Gets or sets the bottom edge position of the FRect.</desc>
    </attr>
    <attr name="bottomleft">
      <desc>Gets or sets the bottom left corner position of the FRect.</desc>
    </attr>
    <attr name="bottomright">
      <desc>Gets or sets the bottom right corner position of the FRect.</desc>
    </attr>
    <method name="ceil">
      <call>ceil () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified FRect.

        This creates a :class:`Rect` using the smallest integral values greater
        or equal to the FRect floating point values.
      </desc>
    </method>
    <attr name="center">
      <desc>Gets or sets the center position of the FRect.</desc>
    </attr>
    <attr name="centerx">
      <desc>Gets or sets the horizontal center position of the FRect.</desc>
    </attr>
    <attr name="centery">
      <desc>Gets or sets the vertical center position of the FRect.</desc>
    </attr>
    <method name="clamp">
      <call>clamp (frect) -> FRect</call>
      <desc>
        Moves the rectangle inside another.

        Returns a new rectangle that is moved to be completely inside
        the argument FRect. If the rectangle is too large to
        fit inside, it is centered inside the argument FRect,
        but its size is not changed.
      </desc>
    </method>
    <method name="clamp_ip">
      <call>clamp_ip (frect) -> None</call>
      <desc>
        Moves the rectangle inside another, in place.

        Same as :meth:`clamp`, but operates in place.
      </desc>
    </method>
    <method name="clip">
      <call>clip (frect) -> FRect</call>
      <desc>
        Crops a rectangle inside another.

        Returns a new rectangle that is cropped to be completely inside
        the argument FRect. If the two rectangles do not
        overlap to begin with, a FRect with 0 size is
        returned. Thus it returns the area, in which both rects overlap.
      </desc>
    </method>
    <method name="collidedict">
      <call>collidedict (dict[, checkvals, key]) -> key, value</call>
      <desc>
        Test if one rectangle in a dictionary intersects.

        Returns the key and value of the first dictionary entry that
        collides with the FRect. If no collisions are found,
        None is returned. Depending on the *checkvals* argument either the
        keys or values of *dict* must be FRect objects. By default,
        the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        FRect itself and a key or value from the passed
        dictionary. It must return True or False ::
        
          def cmpfunc (rect1, rect2):
              ...
              return True

      </desc>
    </method>
    <method name="collidedictall">
      <call>
        collidedictall (dict[, checkvals, key]) -> [(key, value), ...]
      </call>
      <desc>
        Test if all rectangles in a dictionary intersect.

        Returns a list of all the key and value pairs that intersect
        with the FRect. If no collisions are found an empty
        list is returned. Depending on the *checkvals* argument either the
        keys or values of the dict must be FRect objects. By
        default, the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        FRect itself and a key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True

      </desc>
    </method>
    <method name="collidelist">
      <call>collidelist (rects[, key]) -> int</call>
      <desc>
        Test if one rectangle in a list intersects.

        Test whether the rectangle collides with any in a sequence of
        rectangles. The index of the first collision found is
        returned. If no collisions are found an index of -1 is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        FRect itself and a key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidelistall">
      <call>collidelistall (rects[, key]) -> [int, ...]</call>
      <desc>
        Test if all rectangles in a list intersect.

        Returns a list of all the indices that contain rectangles that
        collide with the FRect. If no intersecting rectangles
        are found, an empty list is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        FRect itself and a key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidepoint">
      <call>collidepoint (x, y) -> bool
        collidepoint (point) -> bool</call>
      <desc>
        Test if a point is inside a rectangle.

        Returns True if the given *point* is inside the rectangle. A point
        along the right or bottom edge is not considered to be inside
        the rectangle.
      </desc>
    </method>
    <method name="colliderect">
      <call>colliderect (frect) -> bool</call>
      <desc>
        Test if two rectangles overlap.

        Returns True if any portion of either rectangle overlap (except
        the top+bottom or left+right edges).
      </desc>
    </method>
    <method name="contains">
      <call>contains (frect) -> bool</call>
      <desc>
        Test if one rectangle is inside another.

        Returns True when the argument rectangle is completely inside
        the FRect.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> FRect</call>
      <desc>
        Creates a copy of the FRect.

        Returns a new FRect, that contains the same values as the
        caller.
      </desc>
    </method>
    <method name="fit">
      <call>fit (frect) -> FRect</call>
      <desc>
        Resize and move a rectangle with aspect ratio.

        Returns a new rectangle that is moved and resized to fit
        another. The aspect ratio of the original FRect is
        preserved, so the new rectangle may be smaller than the target
        in either width or height.
      </desc>
    </method>
    <method name="floor">
      <call>floor () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified FRect.

        This creates a :class:`Rect` using the largest integral values less than
        or equal to the FRect floating point values.
      </desc>
    </method>
    <attr name="h">
      <desc>Gets or sets the height of the FRect.</desc>
    </attr>
    <attr name="height">
      <desc>Gets or sets the height of the FRect.</desc>
    </attr>
    <method name="inflate">
      <call>inflate (x, y) -> FRect
        inflate (size) -> FRect</call>
      <desc>
        Grow or shrink the rectangle size.

        Returns a new rectangle with the size changed by the given
        offset. The rectangle remains centered around its current
        center. Negative values will shrink the rectangle.
      </desc>
    </method>
    <method name="inflate_ip">
      <call>inflate_ip (x, y) -> None
        inflate_ip (size) -> None</call>
      <desc>
        Grow or shrink the rectangle size, in place.

        Same as :meth:`inflate`, but operates in place.
      </desc>
    </method>
    <attr name="left">
      <desc>Gets or sets the left edge position of the FRect.</desc>
    </attr>
    <attr name="midbottom">
      <desc>Gets or sets the mid bottom edge position of the FRect.</desc>
    </attr>
    <attr name="midleft">
      <desc>Gets or sets the mid left edge position of the FRect.</desc>
    </attr>
    <attr name="midright">
      <desc>Gets or sets the mid right edge position of the FRect.</desc>
    </attr>
    <attr name="midtop">
      <desc>Gets or sets the mid top edge position of the FRect.</desc>
    </attr>
    <method name="move">
      <call>move (x, y) -> FRect
        move (point) -> FRect</call>
      <desc>
        Moves the rectangle.

        Returns a new rectangle that is moved by the given offset. The *x*
        and *y* arguments can be any float or integer value, positive or
        negative.
      </desc>
    </method>
    <method name="move_ip">
      <call>move_ip (x, y) -> None
        move_ip (point) -> FRect</call>
      <desc>
        Moves the rectangle, in place.

        Same as :meth:`move`, but operates in place.
      </desc>
    </method>
    <attr name="right">
      <desc>Gets or sets the right position of the FRect.</desc>
    </attr>
    <method name="round">
      <call>round () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified FRect.

        This creates a :class:`Rect` using the FRect floating
        point values rounded to the nearest integral value.
      </desc>
    </method>
    <attr name="size">
      <desc>Gets or sets the width and height of the FRect as
      2-value tuple.</desc>
    </attr>
    <attr name="top">
      <desc>Gets or sets the top edge position of the FRect.</desc>
    </attr>
    <attr name="topleft">
      <desc>Gets or sets the top left corner position of the FRect.</desc>
    </attr>
    <attr name="topright">
      <desc>Gets or sets the top right corner position of the FRect.</desc>
    </attr>
    <method name="trunc">
      <call>trunc () -> Rect</call>
      <desc>
        Creates a :class:`Rect` from the specified FRect.

        This creates a :class:`Rect` using truncated integral values from the
        FRect floating point values.
      </desc>
    </method>
    <method name="union">
      <call>union (frect) -> FRect</call>
      <desc>
        Joins two rectangles into one.

        Returns a new rectangle that completely covers the area of the
        two provided rectangles. There may be area inside the new FRect
        that is not covered by the originals.
      </desc>
    </method>
    <method name="union_ip">
      <call>union_ip (frect) -> FRect</call>
      <desc>
        Joins two rectangles into one, in place.

        Same as :meth:`union`, but operates in place.
      </desc>
    </method>
    <attr name="w">
      <desc>Gets or sets the width of the FRect.</desc>
    </attr>
    <attr name="width">
      <desc>Gets or sets the width of the FRect.</desc>
    </attr>
    <attr name="x">
      <desc>Gets or sets the horizontal top left position of the
      FRect.</desc>
    </attr>
    <attr name="y">
      <desc>Gets or sets the vertical top left position of the
      FRect.</desc>
    </attr>
  </class>

  <class name="Rect">
    <constructor>Rect (...) -> Rect</constructor>
    <desc>A class for storing rectangular coordinates.

      A Rect is used to store and manipulate rectangular coordinates.
    </desc>
    <attr name="bottom">
      <desc>Gets or sets the bottom edge position of the Rect.</desc>
    </attr>
    <attr name="bottomleft">
      <desc>Gets or sets the bottom left corner position of the Rect.</desc>
    </attr>
    <attr name="bottomright">
      <desc>Gets or sets the bottom right corner position of the Rect.</desc>
    </attr>
    <attr name="center">
      <desc>Gets or sets the center position of the Rect.</desc>
    </attr>
    <attr name="centerx">
      <desc>Gets or sets the horizontal center position of the Rect.</desc>
    </attr>
    <attr name="centery">
      <desc>Gets or sets the vertical center position of the Rect.</desc>
    </attr>
    <method name="clamp">
      <call>clamp (rect) -> Rect</call>
      <desc>
        Moves the rectangle inside another.

        Returns a new rectangle that is moved to be completely inside
        the argument Rect. If the rectangle is too large to fit inside,
        it is centered inside the argument Rect, but its size is not
        changed.
      </desc>
    </method>
    <method name="clamp_ip">
      <call>clamp_ip (rect) -> None</call>
      <desc>
        Moves the rectangle inside another, in place.

        Same as :meth:`clamp`, but operates in place.
      </desc>
    </method>
    <method name="clip">
      <call>clip (rect) -> Rect</call>
      <desc>
        Crops a rectangle inside another.

        Returns a new rectangle that is cropped to be completely inside
        the argument Rect. If the two rectangles do not overlap
        to begin with, a Rect with 0 size is returned. Thus it
        returns the area, in which both rects overlap.
      </desc>
    </method>
    <method name="collidedict">
      <call>collidedict (dict[, checkvals, key]) -> key, value</call>
      <desc>
        Test if one rectangle in a dictionary intersects.

        Returns the key and value of the first dictionary entry that
        collides with the Rect. If no collisions are found,
        None is returned. Depending on the *checkvals* argument either the
        keys or values of the *dict* must be Rect objects. By
        default, the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        Rect itself and a key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidedictall">
      <call>collidedictall (dict[, checkvals, key]) -> [(key, value), ...]</call>
      <desc>
        Test if all rectangles in a dictionary intersect.

        Returns a list of all the key and value pairs that intersect
        with the Rect. If no collisions are found an empty list
        is returned. Depending on the *checkvals* argument either the keys
        or values of the *dict* must be Rect objects. By default,
        the keys are checked.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        Rect itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidelist">
      <call>collidelist (list[, key]) -> int</call>
      <desc>
        Test if one rectangle in a list intersects.

        Test whether the rectangle collides with any in a sequence of
        rectangles. The index of the first collision found is
        returned. If no collisions are found an index of -1 is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        Rect itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidelistall">
      <call>collidelistall (list[, key]) -> [int, ...]</call>
      <desc>
        Test if all rectangles in a list intersect.

        Returns a list of all the indices that contain rectangles that
        collide with the Rect. If no intersecting rectangles are found,
        an empty list is returned.

        You can provide your own comparision function as *key*
        argument. The comparision function will take two arguments, the
        Rect itself and an key or value from the passed
        dictionary. It must return True or False ::

          def cmpfunc (rect1, rect2):
              ...
              return True
      </desc>
    </method>
    <method name="collidepoint">
      <call>collidepoint (x, y) -> bool
        collidepoint (point) -> bool</call>
      <desc>
        Test if a point is inside a rectangle.

        Returns True if the given point is inside the rectangle. A point
        along the right or bottom edge is not considered to be inside
        the rectangle.
      </desc>
    </method>
    <method name="colliderect">
      <call>colliderect (rect) -> bool</call>
      <desc>
        Test if two rectangles overlap.

        Returns True if any portion of either rectangle overlap (except
        the top+bottom or left+right edges).
      </desc>
    </method>
    <method name="contains">
      <call>contains (rect) -> bool</call>
      <desc>
        Test if one rectangle is inside another.

        Returns True when the argument rectangle is completely inside
        the Rect.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> Rect</call>
      <desc>
        Creates a copy of the Rect.

        Returns a new Rect, that contains the same values as the
        caller.
      </desc>
    </method>
    <method name="fit">
      <call>fit (rect) -> Rect</call>
      <desc>
        Resize and move a rectangle with aspect ratio.

        Returns a new rectangle that is moved and resized to fit
        another. The aspect ratio of the original Rect is preserved, so
        the new rectangle may be smaller than the target in either width
        or height.
      </desc>
    </method>
    <attr name="h">
      <desc>Gets or sets the height of the Rect.</desc>
    </attr>
    <attr name="height">
      <desc>Gets or sets the height of the Rect.</desc>
    </attr>
    <method name="inflate">
      <call>inflate (x, y) -> Rect
        inflate (size) -> Rect</call>
      <desc>
        Grow or shrink the rectangle size.

        Returns a new rectangle with the size changed by the given
        offset. The rectangle remains centered around its current
        center. Negative values will shrink the rectangle.
      </desc>
    </method>
    <method name="inflate_ip">
      <call>inflate_ip (x, y) -> None
        inflate_ip (size) -> Rect</call>
      <desc>
        Grow or shrink the rectangle size, in place.

        Same as :meth:`inflate`, but operates in place.
      </desc>
    </method>
    <attr name="left">
      <desc>Gets or sets the left edge position of the Rect.</desc>
    </attr>
    <attr name="midbottom">
      <desc>Gets or sets the mid bottom edge position of the Rect.</desc>
    </attr>
    <attr name="midleft">
      <desc>Gets or sets the mid left edge position of the Rect.</desc>
    </attr>
    <attr name="midright">
      <desc>Gets or sets the mid right edge position of the Rect.</desc>
    </attr>
    <attr name="midtop">
      <desc>Gets or sets the mid top edge position of the Rect.</desc>
    </attr>
    <method name="move">
      <call>move (x, y) -> Rect
        move (point) -> Rect</call>
      <desc>
        Moves the rectangle.

        Returns a new rectangle that is moved by the given offset. The *x*
        and *y* arguments can be any integer value, positive or negative.
      </desc>
    </method>
    <method name="move_ip">
      <call>move_ip (x, y) -> None
        move_ip (point) -> None</call>
      <desc>
        Moves the rectangle, in place.

        Same as :meth:`move`, but operates in place.
      </desc>
    </method>
    <attr name="right">
      <desc>Gets or sets the right position of the Rect.</desc>
    </attr>
    <attr name="size">
      <desc>Gets or sets the width and height of the Rect as
      2-value tuple.</desc>
    </attr>
    <attr name="top">
      <desc>Gets or sets the top edge position of the Rect.</desc>
    </attr>
    <attr name="topleft">
      <desc>Gets or sets the top left corner position of the Rect.</desc>
    </attr>
    <attr name="topright">
      <desc>Gets or sets the top right corner position of the Rect.</desc>
    </attr>
    <method name="union">
      <call>union (rect) -> Rect</call>
      <desc>
        Joins two rectangles into one.

        Returns a new rectangle that completely covers the area of the
        two provided rectangles. There may be area inside the new Rect
        that is not covered by the originals.
      </desc>
    </method>
    <method name="union_ip">
      <call>union_ip (rect) -> Rect</call>
      <desc>
        Joins two rectangles into one, in place.

        Same as :meth:`union`, but operates in place.
      </desc>
    </method>
    <attr name="w">
      <desc>Gets or sets the width of the Rect.</desc>
    </attr>
    <attr name="width">
      <desc>Gets or sets the width of the Rect.</desc>
    </attr>
    <attr name="x">
      <desc>Gets or sets the horizontal top left position of the Rect.</desc>
    </attr>
    <attr name="y">
      <desc>Gets or sets the vertical top left position of the Rect.</desc>
    </attr>
  </class>

  <class name="Surface">
    <constructor>Surface () -> Surface</constructor>
    <desc>
      An abstract base class for arbitrary Surface objects.
    
      You should not instantiate this class directly. 
    </desc>
    <method name="blit">
      <call>blit (**kwds) -> object</call>
      <desc>
        Performs a blit operation on the Surface.

        The behavior, arguments and return value depend on the concrete
        Surface implementation.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> Surface</call>
      <desc>Creates a copy of this Surface.</desc>
    </method>
    <method name="get_at">
      <call>get_at (x, y) -> Color
      get_at (point) -> Color
      </call>
      <desc>
        Gets the Surface pixel value at the specified point.
      </desc>
    </method>
    <attr name="height">
      <desc>Gets the height of the Surface.</desc>
    </attr>
    <attr name="pixels">
      <desc>Gets a buffer with the pixels of the Surface.</desc>
    </attr>
    <method name="set_at">
      <call>set_at (x, y, color) -> None
      set_at (point, color) -> None
      </call>
      <desc>
        Sets the Surface pixel value at the specified point.
      </desc>
    </method>
    <attr name="size">
      <desc>Gets the width and height of the Surface.</desc>
    </attr>
    <attr name="width">
      <desc>Gets the width of the Surface.</desc>
    </attr>
  </class>

  <class name="Font">
    <constructor>Font () -> Font</constructor>
    <desc>
      An abstract base class for arbitrary Font objects.
    
      You should not instantiate this class directly.
    </desc>
    <method name="render">
      <call>render (**kwds) -> object</call>
      <desc>
          Renders the specified text using the Font object. The exact input
          arguments and return value is dependand on each specific Font
          implementation.
      </desc>
    </method>
    <method name="copy">
      <call>copy () -> Font</call>
      <desc>Creates a copy of this Font.</desc>
    </method>
    <attr name="height">
      <desc>Gets the standard height of the Font typography.</desc>
    </attr>
    <attr name="size">
      <desc>Gets the width and height of the Font typography.</desc>
    </attr>
    <attr name="name">
      <desc>Gets the name of the loaded Font.</desc>
    </attr>
    <attr name="style">
      <desc>Gets or sets the style used to render the Font.</desc>
    </attr>
  </class>

</module>

