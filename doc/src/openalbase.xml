<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE module SYSTEM "api.dtd">

<module name="pygame2.openal.base">
  <alias>pygame2.openal</alias>
  <short>basic OpenAL wrapper module</short>
  <desc>
    .. todo::
    
       detailled description of the OpenAL model, including contexts, devices,
       source and listener bindings and the context/state driven behaviour.
    
    Type identifiers for the property get and set methods:
    
    +------+------------------------------------------------------------+
    | 'b'  | Get or set a single boolean value (e.g. AL_TRUE)           |
    +------+------------------------------------------------------------+
    | 'ba' | Get or set an array of boolean values. The array can be    |
    |      | any type of sequence containing matching values.           |
    +------+------------------------------------------------------------+
    | 'i'  | Get or set a single integer value.                         |
    +------+------------------------------------------------------------+
    | 'i3' | Get or set an triplet of integer values. The array can be  |
    |      | any type of sequence containing matching values.           |
    +------+------------------------------------------------------------+
    | 'ia' | Get or set an array of integer values. The array can be    |
    |      | any type of sequence containing matching values.           |
    +------+------------------------------------------------------------+
    | 'f'  | Get or set a single floating point value.                  |
    +------+------------------------------------------------------------+
    | 'f3' | Get or set an triplet of floating point values. The array  |
    |      | can be any type of sequence containing matching values.    |
    +------+------------------------------------------------------------+
    | 'fa' | Get or set an array of floating point values. The array    |
    |      | can be any type of sequence containing matching values.    |
    +------+------------------------------------------------------------+
    | 'd'  | Get or set a single double precision floating point value. |
    +------+------------------------------------------------------------+
    | 'da' | Get or set an array of double precision floating point     |
    |      | values. The array can be any type of sequence containing   |
    |      | matching values.                                           |
    +------+------------------------------------------------------------+
  </desc>

  <class name="Buffers">
    <constructor>Buffers () -> NotImplementedError</constructor>
    <desc>
      Buffers objects are used by OpenAL to buffer and provide PCM data
      for playback, recording and manipulation.
      
      The Buffers object provides methods and properties to manipulate
      certain aspects of the buffered data and can be queued to multiple
      Sources within the same context.

      Buffers instances cannot be created directly, but are bound to a
      :class:`Device`. To create a Buffers instance for the currently
      active :class:`Device`, use the :meth:`Context.create_buffers` method
      on the currently active :class:`Context`.
    </desc>
    <example></example>
    <method name="buffer_data">
      <call>buffer_data (bufnum, format, data, samplerate) -> None</call>
      <desc>Buffers a chunk of *data* into one of the created buffers.
      
        Buffers a chunk of PCM *data* into the buffer at *bufnum*. *format*
        describes the audio format of the data (see
        :mod:`pygame2.openal.constants` for
        more details). *samplerate* denotes the sample rate in Hz.
      </desc>
      <example></example>
    </method>
    <attr name="buffers">
      <desc>Gets the buffer identifiers used in the Buffers instance.</desc>
      <example></example>
    </attr>
    <attr name="count">
      <desc>Gets the number of buffers managed in the Buffers instance.</desc>
      <example></example>
    </attr>
    <method name="get_prop">
      <call>get_prop (bufnum, prop, type) -> value or (value, ...) </call>
      <desc>Retrieves the value(s) of an OpenAL property for the Buffers.
      
        Retrieves the value or values of a buffer-related OpenAL property for
        the buffer identified by *bufnum*. *prop* can be any valid buffer
        constant and *type* **must** be a valid value type identifier for the
        constant.
      </desc>
      <example></example>
    </method>
    <method name="set_prop">
      <call>set_prop (bufnum, prop, value[,type]) -> None</call>
      <desc>Sets the value(s) of an OpenAL property for the Buffers.
      
        Sets the value or values of a buffer-related OpenAL property for the 
        buffer identified by *bufnum*. *prop* can be any valid buffer
        constant, while *value* **must** be valid for the constant.
        
        If *type* is omitted, the function tries to guess, which type should be
        used from the passed value(s). Guessing tries to convert values
        implicitly, where possible, so if there are ambiguous values, it is
        better to provide *type*.
      </desc>
      <example></example>
    </method>
  </class>

  <class name="CaptureDevice">
    <constructor>CaptureDevice (frequency, format, bufsize) -> CaptureDevice
    CaptureDevice (name, frequency, format, bufsize) -> CaptureDevice
    </constructor>
    <desc>Creates a sound capturing device.
    
    The CaptureDevice acts as recorder for a certain hardware device and
    allows the caller to record incoming sound samples (e.g. from a
    microphone or line-in device).

    The captured samples will be stored in an internal buffer, which is
    guaranteed to hold *bufsize* samples. Depending on the passed
    *format* and *frequency*, captured samples can vary in their byte
    size (see :mod:`pygame2.openal.constants` for more details) and
    speed of occurance.
    </desc>
    <example></example>
    <attr name="format">
      <desc>Gets the set audio format for the CaptureDevice.</desc>
      <example></example>
    </attr>
    <attr name="frequency">
      <desc>Gets the set frequency in Hz for the CaptureDevice.</desc>
      <example></example>
    </attr>
    <method name="get_samples">
      <call>get_samples ([buffer]) -> (str or bytes) or int</call>
      <desc>Retrieves the available samples from the CaptureDevice.

      Retrieves the samples that are available on the CaptureDevice. If
      a *buffer* is provided, the samples will be directly written to
      the buffer and the amount of bytes written will be returned.

      If no *buffer* is provided, the retrieved samples will be returned
      as byte sequence (byte string or string).
      </desc>
      <example></example>
    </method>
    <attr name="size">
      <desc>Gets the default buffer size for the CaptureDevice.</desc>
      <example></example>
    </attr>
    <method name="start">
      <call>start () ->None</call>
      <desc>Starts capturing incoming samples on the device.

      Starts capturing incoming samples for the CaptureDevice. The
      samples will be stored in the CaptureDevice's internal buffer. If
      the buffer is full, the oldest samples will be overwritten with
      the newest samples (ring buffer).
      </desc>
      <example></example>
    </method>
    <method name="stop">
      <call>stop () -> None</call>
      <desc>Stops capturing incoming samples.</desc>
      <example></example>
    </method>
  </class>

  <class name="Context">
    <constructor>Context (device[,attribtes]) -> Context</constructor>
    <desc>Creates a new Context for a specific Device.
    
      OpenAL contexts represent logical state groups, where
      :class:`Sources` and a :class:`Listener` are managed and audio
      data is correctly streamed to the underlying output
      :class:`Device`.

      Contexts can be created for multiple devices and independently
      managed without influencing each other. To be processed correctly
      at a certain time, a :class:`Context` must be set as the *current*
      one in OpenAL. This will cause OpenAL to process only data from
      that :class:`Context` to and from the audio hardware.

      Most methods and properties will fail for a :class:`Context` that
      is not marked as the *current* one. So before accessing any member
      of a :class:`Context`, make sure, you marked it as *current*.
    </desc>
    <example></example>
    <method name="create_buffers">
      <call>create_buffers (amount) -> Buffers</call>
      <desc>Creates a Buffers instance with *amount* buffers for the Context.
      </desc>
      <example></example>
    </method>
    <method name="create_sources">
      <call>create_sources (amount) -> Sources</call>
      <desc>Creates a Sources instance with *amount* sources for the Context.
      </desc>
      <example></example>
    </method>
    <attr name="device">
      <desc>Gets the :class:`Device` the Context is using.</desc>
      <example></example>
    </attr>
    <method name="disable">
      <call>disable (value) -> None</call>
      <desc>Disables a certain context-specific setting.</desc>
      <example></example>
    </method>
    <attr name="distance_model">
      <desc>Gets or sets the distance model setting for the
      :class:`Context`.</desc>
      <example></example>
    </attr>
    <attr name="doppler_factor">
      <desc>Gets or sets the doppler factor setting for the
      :class:`Context`.</desc>
      <example></example>
    </attr>
    <method name="enable">
      <call>enable (value) -> None</call>
      <desc>Enables a certain context-specific setting.</desc>
      <example></example>
    </method>
    <attr name="is_current">
      <desc>Gets, whether the :class:`Context` is marked the current one
      to process.</desc>
      <example></example>
    </attr>
    <method name="is_enabled">
      <call>is_enabled (value) -> bool</call>
      <desc>Checks, whether a certain setting is enabled.</desc>
      <example></example>
    </method>
    <attr name="listener">
      <desc>Gets the :class:`Listener` for the :class:`Context`.</desc>
      <example></example>
    </attr>
    <method name="make_current">
      <call>make_current () -> bool</call>
      <desc>Tries to mark the :class:`Context` as current.
      
        Tries to mark the :class:`Context` as the current one. If the
        :class:`Context` could not be marked sucessfully, False will be
        returned, otherwise True.

        Any other :class:`Context`, which was previously marked as
        current, will loose this state.
      </desc>
      <example></example>
    </method>
    <method name="process">
      <call>process () -> None</call>
      <desc>Processes the :class:`Context`.
      
        Processes the :class:`Context`, causing it to update any
        internal states, stream audio data to and from the hardware,
        update the internal source and listener positions and so forth.
      </desc>
      <example></example>
    </method>
    <attr name="speed_of_sound">
      <desc>Gets or sets the value of the speed of sound for the
      :class:`Context`.</desc>
      <example></example>
    </attr>
    <method name="suspend">
      <call>suspend () -> None</call>
      <desc>Suspends the :class:`Context` from processing any data.</desc>
      <example></example>
    </method>
  </class>

  <class name="Device">
    <constructor>Device ([name]) -> Device</constructor>
    <desc>Creates a sound output device.

    The Device class acts as sound streaming sink, by default for
    playing audio data (The :class:`CaptureDevice` also inherits from
    :class:`Device`, but acts as recorder).
    </desc>
    <example></example>
    <attr name="extensions">
      <desc>Gets a list of available extensions for the Device and
      OpenAL implementation.
      </desc>
      <example></example>
    </attr>
    <method name="get_enum_value">
      <call>get_enum_value (name) -> long</call>
      <desc>Gets the value of a Device-specific OpenAL enumeration name.
      </desc>
      <example></example>
    </method>
    <method name="get_error">
      <call>get_error () -> str</call>
      <desc>
        Gets the last OpenAL error message occured on the Device.

        OpenAL devices maintain an internal error message. This message
        will usually be given to you when a :exc:`pygame2.Error` is
        raised.

        You will rarely need to call this function.
      
        .. note::
        
          Once called, the internal error message will be cleared, so
          that subsequent calls of this function will return *None*,
          until a new error occurs.
    </desc>
      <desc></desc>
      <example></example>
    </method>
    <method name="has_extension">
      <call>has_extension (extname) -> bool</call>
      <desc>Checks, whether a certain extension is available on the Device.
      </desc>
      <example></example>
    </method>
    <attr name="name">
      <desc>Gets the name of the Device as reported by OpenAL.</desc>
      <example></example>
    </attr>
  </class>

  <class name="Listener">
    <constructor>Listener () -> NotImplementedError</constructor>
    <desc>
      The Listener represents the user hearing the sounds played by OpenAL in a
      specific Context. Source playback is done relative to the position of the
      Listener in the 3D space.
    
      Listener instances cannot be created directly, but are bound to a
      :class:`Context`. To create (or get) a Listener instance for the
      currently active :class:`Context`, use the :attr:`Context.listener`
      property.
    </desc>
    <example></example>
    <method name="get_prop">
      <call>get_prop (prop, type) -> value or (value, ...)</call>
      <desc>Retrieves the value(s) of an OpenAL property for the Listener.
      
        Retrieves the value or values of a listener-related OpenAL property.
        *prop* can be any valid listener constant and *type* **must** be a
        valid value type identifier for the constant.
      </desc>
      <example></example>
    </method>
    <method name="set_prop">
      <call>set_prop (prop, value[, type]) -> None</call>
      <desc>Sets the value(s) of an OpenAL property for the Listener.
      
        Sets the value or values of a listener-related OpenAL property.
        *prop* can be any valid listener constant, while *value* **must** be
        valid for the constant.
        
        If *type* is omitted, the function tries to guess, which type should be
        used from the passed value(s). Guessing tries to convert values
        implicitly, where possible, so if there are ambiguous values, it is
        better to provide *type*.
      </desc>
      <example></example>
    </method>
  </class>

  <class name="Sources">
    <constructor>Sources () -> NotImplementedError</constructor>
    <desc>
      Sources store locations, directions, and other attributes of an object in
      3D space and have a buffer associated with them for playback. When the
      program wants to play a sound, it controls execution through a source
      object. Sources are processed independently from each other.
      
      Sources instances cannot be created directly, but are bound to a
      :class:`Context`. To create a Sources instance for the currently
      active :class:`Context`, use the :meth:`Context.create_sources` method.
    </desc>
    <example></example>
    <attr name="count">
      <desc>Gets the number of sources managed in the Sources instance.</desc>
      <example></example>
    </attr>
    <method name="get_prop">
      <call>get_prop (sourcenum, prop, type) -> value or (value, ...)</call>
      <desc>Retrieves the value(s) of an OpenAL property for the Sources.
      
        Retrieves the value or values of a sources-related OpenAL property for
        the source identified by *sourcenum*. *prop* can be any valid source
        constant and *type* **must** be a valid value type identifier for the
        constant.
      </desc>
      <example></example>
    </method>
    <method name="pause">
      <call>pause (sourcenum) -> None
        pause ((sourcenum1, sourcenum2, ...)) -> None
      </call>
      <desc>Pauses a single source or a set of sources.
      
        Pauses a single source identified by *sourcenum* or a set of sources
        identified by the passed sequence of source identifiers.
      </desc>
      <example></example>
    </method>
    <method name="play">
      <call>play (sourcenum) -> None
        play ((sourcenum1, sourcenum2, ...)) -> None
      </call>
      <desc>Plays a single source or a set of sources.
      
        Plays a single source identified by *sourcenum* or a set of sources
        identified by the passed sequence of source identifiers.
      </desc>
      <example></example>
    </method>
    <method name="queue_buffers">
      <call>queue_buffers (sourcenum, buffers) -> None</call>
      <desc>Queues a :class:`Buffers` on a source.

        Queues a :class:`Buffers` instance holding one or multiple audio buffers
        on the source identified by *sourcenum*. The audio buffers in *buffers*
        will be played in sequence.
        
        To retrieve the number of audio buffers already processed, you can query
        the source with the :const:`AL_BUFFERS_PROCESSED` constant.
      </desc>
      <example></example>
    </method>
    <method name="rewind">
      <call>rewind (sourcenum) -> None
        rewind ((sourcenum1, sourcenum2, ...)) -> None
      </call>
      <desc>Rewinds a single source or a set of sources.
      
        Rewinds a single source identified by *sourcenum* or a set of sources
        identified by the passed sequence of source identifiers.
      </desc>
      <example></example>
    </method>
    <method name="set_prop">
      <call>set_prop (sourcenum, prop, value[, type]) -> None</call>
      <desc>Sets the value(s) of an OpenAL property for the Sources.
      
        Sets the value or values of a sources-related OpenAL property for the 
        source identified by *sourcenum*. *prop* can be any valid source
        constant, while *value* **must** be valid for the constant.
        
        If *type* is omitted, the function tries to guess, which type should be
        used from the passed value(s). Guessing tries to convert values
        implicitly, where possible, so if there are ambiguous values, it is
        better to provide *type*.
      </desc>
      <example></example>
    </method>
    <attr name="sources">
      <desc>Gets the source identifiers used in the Sources instance.</desc>
      <example></example>
    </attr>
    <method name="stop">
      <call>stop (sourcenum) -> None
        stop ((sourcenum1, sourcenum2, ...)) -> None
      </call>
      <desc>Stops playing a single source or a set of sources.
      
        Stops playing a single source identified by *sourcenum* or a set of
        sources identified by the passed sequence of source identifiers.
      </desc>
      <example></example>
    </method>
    <method name="unqueue_buffers">
      <call>unqueue_buffers (sourcenum, buffers) -> None</call>
      <desc>Unqueues processed :class:`Buffers` from a source
      
        Unqueus an already processed :class:`Buffers` with one or multiple audio
        buffers from the source identified by *sourcenum*.
        
        .. note::
        
          This will only succeed, when all buffers within the :class:`Buffers`
          instance were processed by the source. Otherwise a
          :exc:`pygame2.Error` will be raised.
      </desc>
      <example></example>
    </method>
  </class>

  <func name="al_get_string">
    <call>al_get_string (prop) -> str</call>
    <desc>Retrieves an OpenAL string property.
    
      For valid property values, see :mod:`pygame2.openal.constants`.
    </desc>
    <example>
      import pygame2.openal as openal
      import pygame2.openal.constants as const
      
      print (openal.al_get_string (const.AL_VENDOR))
    </example>
  </func>
  <func name="get_default_capture_device_name">
    <call>get_default_capture_device_name () -> str</call>
    <desc>Gets the name of the default capture device.</desc>
    <example></example>
  </func>
  <func name="get_default_output_device_name">
    <call>get_default_output_device_name () -> str</call>
    <desc>Gets the name of the default output device.</desc>
    <example></example>
  </func>
  <func name="get_enum_value">
    <call>get_enum_value (name) -> long</call>
    <desc>Gets the value of an OpenAL enumeration name.</desc>
    <example></example>
  </func>
  <func name="get_error">
    <call>get_error () -> str</call>
    <desc>
      Gets the last OpenAL error message occured.

      OpenAL maintains an internal error message. This message will usually
      be given to you when a :exc:`pygame2.Error` is raised.

      You will rarely need to call this function.
      
      .. note::
        
        Once called, the internal OpenAL error message will be cleared, so that
        subsequent calls of this function will return *None*, until a new
        OpenAL error occurs.
    </desc>
    <example></example>
  </func>
  <func name="init">
    <call>init ()</call>
    <desc>Initializes the underlying OpenAL library.

      .. note::    
        
        This function is currently only available for compliance with other
        pygame2 modules, but does not actually perform anything. The behaviour
        might change in later pygame2 versions, so it is generally safe to call
        this function.
    </desc>
    <example></example>
  </func>
  <func name="is_extension_present">
    <call>is_extension_present (name[, device]) -> bool</call>
    <desc>Checks, whether the specified extension is available.
    
      Checks, whether the extension specified by *name* is available in the
      current OpenAL implementation. If a *device* is passed, the OpenAL's
      :pygame2.openal.Device` will be checked for the extension.
    </desc>
    <example></example>
  </func>
  <func name="list_capture_devices">
    <call>list_capture_devices () -> [str, str, ...]</call>
    <desc>Retrieves a list of available capture devices.
    
      Retrieves a list of available and supported capture device names. If no
      capture devices could be found, an empty list is returned.
    </desc>
    <example></example>
  </func>
  <func name="list_output_devices">
    <call>list_output_devices</call>
    <desc>Retrieves a list of available output devices.
    
      Retrieves a list of available and supported output device names. If no
      output devices could be found, an empty list is returned.
    </desc>
    <example></example>
  </func>
  <func name="quit">
    <call>quit ()</call>
    <desc>Shuts down the underlying OpenAL library.
    
      .. note::    
        
        This function is currently only available for compliance with other
        pygame2 modules, but does not actually perform anything. The behaviour
        might change in later pygame2 versions, so it is generally safe to call
        this function.
    </desc>
    <example></example>
  </func>
  <func name="set_current_context">
    <call>set_current_context (context) -> bool</call>
    <desc>Switches the current OpenAL context.
    
      Switches the current OpenAL context. The current OpenAL context can then
      be influenced in various ways, such as attaching sources, buffers and
      tweaking its settings.
      
      Returns True, if the context could be switched successfully, otherwise
      False.
    </desc>
    <example></example>
  </func>
</module>

