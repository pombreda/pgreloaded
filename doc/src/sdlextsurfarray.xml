<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE module SYSTEM "api.dtd">

<module name="pygame2.sdlext.surfarray">
  <short>
    module for accessing surface pixel data using numeric array interfaces.
  </short>
  <desc>
    .. note::
    
      The module is subject to change in future version and thus is
      marked as deprecated.

    Functions to convert pixel data between pygame Surfaces and arrays. This
    module will only be functional when pygame can use the external Numpy or
    Numeric packages.
  
    Every pixel is stored as a single integer value to represent the red,
    green, and blue colors. The 8bit images use a value that looks into a
    colormap. Pixels with higher depth use a bit packing process to place
    three or four values into a single number.
  
    The arrays are indexed by the X axis first, followed by the Y
    axis. Arrays that treat the pixels as a single integer are referred to
    as 2D arrays. This module can also separate the red, green, and blue
    color values into separate indices. These types of arrays are referred
    to as 3D arrays, and the last index is 0 for red, 1 for green, and 2 for
    blue.

    Supported array types are
  
    * numeric
    * numpy

    The default will be Numeric, if installed. Otherwise, numpy will be set
    as default if installed. If neither Numeric nor numpy are installed, the
    module will raise an ImportError.
  
    The array type to use can be changed at runtime using the use_arraytype()
    method, which requires one of the above types as string.
  
    .. note:: 
      
      numpy and Numeric are not completely compatible. Certain array
      manipulations, which work for one type, might behave differently or even
      completely break for the other.
  
      Additionally, in contrast to Numeric numpy does use unsigned 16-bit
      integers. Images with 16-bit data will be treated as unsigned
      integers. Numeric instead uses signed integers for the representation,
      which is important to keep in mind, if you use the module's functions
      and wonder about the values.
  </desc>
  <example></example>

  <func name="array2d">
    <call>array2d (Surface) -> array</call>
    <desc>
      Copy pixels into a 2d array.

      Copy the pixels from a Surface into a 2D array. The bit depth of
      the surface will control the size of the integer values, and will
      work for any type of pixel format.
      
      This function will temporarily lock the Surface as pixels are
      copied (see the Surface.lock - lock the Surface memory for pixel
      access method).
    </desc>
    <example></example>
  </func>
  <func name="array3d">
    <call>array3d (Surface) -> array</call>
    <desc>
      Copy pixels into a 3d array.
      
      Copy the pixels from a Surface into a 3D array. The bit depth of
      the surface will control the size of the integer values, and will
      work for any type of pixel format.
      
      This function will temporarily lock the Surface as pixels are copied
      (see the Surface.lock - lock the Surface memory for pixel access
      method).
    </desc>
    <example></example>
  </func>
  <func name="array_alpha">
    <call>array_alpha (Surface) -> array</call>
    <desc>
      Copy pixel alphas into a 2d array.
      
      Copy the pixel alpha values (degree of transparency) from a Surface
      into a 2D array. This will work for any type of Surface
      format. Surfaces without a pixel alpha will return an array with all
      opaque values.
      
      This function will temporarily lock the Surface as pixels are copied
      (see the Surface.lock - lock the Surface memory for pixel access
      method).
    </desc>
    <example></example>
  </func>
  <func name="array_colorkey">
    <call>array_colorkey (Surface) -> array</call>
    <desc>
      Copy the colorkey values into a 2d array.
      
      Create a new array with the colorkey transparency value from each
      pixel. If the pixel matches the colorkey it will be fully
      transparent; otherwise it will be fully opaque.

      This will work on any type of Surface format. If the image has no
      colorkey a solid opaque array will be returned.
      
      This function will temporarily lock the Surface as pixels are
      copied.
    </desc>
    <example></example>
  </func>
  <func name="blit_array">
    <call>blit_array (Surface, array) -> None</call>
    <desc>
      Blit directly from a array values.
      
      Directly copy values from an array into a Surface. This is faster
      than converting the array into a Surface and blitting. The array
      must be the same dimensions as the Surface and will completely
      replace all pixel values.
      
      This function will temporarily lock the Surface as the new values
      are copied.
    </desc>
    <example></example>
  </func>
  <func name="get_arraytype">
    <call>get_arraytype () -> str</call>
    <desc>
      Gets the currently active array type.
      
      Returns the currently active array type. This will be a value of the
      get_arraytypes() tuple and indicates which type of array module is
      used for the array creation.
    </desc>
    <example></example>
  </func>
  <func name="get_arraytypes">
    <call>get_arraytypes () -> tuple</call>
    <desc>
      Gets the array system types currently supported.
      
      Checks, which array system types are available and returns them as a
      tuple of strings. The values of the tuple can be used directly in
      the use_arraytype () method.
      
      If no supported array system could be found, None will be returned.
    </desc>
    <example></example>
  </func>
  <func name="make_surface">
    <call>make_surface (array) -> Surface</call>
    <desc>
      Copy an array to a new surface.

      Create a new Surface that best resembles the data and format on the
      array. The array can be 2D or 3D with any sized integer values.
    </desc>
    <example></example>
  </func>
  <func name="map_array">
    <call>map_array (Surface, array3d) -> array2d</call>
    <desc>
      Map a 3D array into a 2D array.

      Convert a 3D array into a 2D array. This will use the given Surface
      format to control the conversion. Palette surface formats are not
      supported.
    </desc>
    <example></example>
  </func>
  <func name="pixels2d">
    <call>pixels2d (Surface) -> array</call>
    <desc>
      Reference pixels into a 2d array.
      
      Create a new 2D array that directly references the pixel values in
      a Surface. Any changes to the array will affect the pixels in the
      Surface. This is a fast operation since no data is copied.

      Pixels from a 24-bit Surface cannot be referenced, but all other
      Surface bit depths can.

      The Surface this references will remain locked for the lifetime of
      the array (see the Surface.lock - lock the Surface memory for
      pixel access method).
    </desc>
    <example></example>
  </func>
  <func name="pixels3d">
    <call>pixels3d (Surface) -> array</call>
    <desc>
      Reference pixels into a 3d array.
      
      Create a new 3D array that directly references the pixel values in a
      Surface. Any changes to the array will affect the pixels in the
      Surface. This is a fast operation since no data is copied.
      
      This will only work on Surfaces that have 24-bit or 32-bit
      formats. Lower pixel formats cannot be referenced.
      
      The Surface this references will remain locked for the lifetime of
      the array (see the Surface.lock - lock the Surface memory for pixel
      access method).
    </desc>
    <example></example>
  </func>
  <func name="pixels_alpha">
    <call>pixels_alpha (Surface) -> array</call>
    <desc>
      Reference pixel alphas into a 2d array.

      Create a new 2D array that directly references the alpha values
      (degree of transparency) in a Surface. Any changes to the array will
      affect the pixels in the Surface. This is a fast operation since no
      data is copied.
      
      This can only work on 32-bit Surfaces with a per-pixel alpha value.
      
      The Surface this array references will remain locked for the
      lifetime of the array.
    </desc>
    <example></example>
  </func>
  <func name="use_arraytype">
    <call>use_arraytype (arraytype) -> None</call>
    <desc>
      Sets the array system to be used for surface arrays.
      
      Uses the requested array type for the module functions.
      Currently supported array types are:
      
      * numeric
      * numpy

      If the requested type is not available, a ValueError will be raised.
    </desc>
    <example></example>
  </func>
</module>
